# <center>虚拟机栈(本地方法栈)
## 简介
## 为什么用栈？
  java使用栈式指令集，与之对应的通常是寄存器指令集。栈式指令不需要依赖寄存器，java为了跨平台性选择了栈式指令。
## 栈式指令集与寄存器指令集对比
* 可移植性：寄存器指令集完全依赖cpu寄存器的架构，因此可移植性差。
* 指令特点：栈式指令集多数使用零地址指令，指令短但指令集多。寄存器指令多使用一地址、二地址、三地址指令，指令长但是指令集少。因此完成相同的操作，栈式指令集所需要的指令跟多。
* 执行速度：寄存器指令优于栈式指令，因为寄存器指令所需要的指令更少。
## jvm中的虚拟机栈(本地方法栈)
栈解决了程序的运行问题，堆解决了数据的存储问题
* 每个线程有一个虚拟机栈，因此虚拟机栈的生命周期与线程一致
* 线程中的方法调用对应栈中的栈帧
* 栈没有gc，但会有oom问题
## 栈帧的内部结构
 1. 局部变量表
    - 定义一个数字数组，用于存储方法的形参和方法体内的局部变量。数据类型包括基本数据类型、对象引用和returnAddress返回值类型
    - 局部变量表所需要的容量在编译期间就确定下来，保存在方法的Code属性中的maximum local variables中，运行期间不会改变 
    - 方法的参数和局部变量越多，栈帧越大
    - 进一步栈内能容纳的栈帧就变少，方法能嵌套调用的层数也会减少
    - 线程私有，不存在数据安全问题
    - 生命周期随着方法的结束而结束
    - 在当前方法不是静态方法时，局部变量表的第一个默认变量为this
    - 局部变量表的slot可以复用
 2. 操作数栈
    - 指令的操作数保存在操作数栈中(也叫表达式栈)
    - 主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。
    - 编译器就确定长度，保存在方法的Code属性中的maxstack
    - 不能使用索引访问
    - 方法的返回值会保存在操作数栈中
    - 操作数栈总以最小的数据类型保存数据，例如8可以存放在 byte 类型中，所以压入操作数栈的类型为byte ，而不是int。但是存储在局部变量的时候，会转成 int 类型的变量：istore_4
    - 栈顶缓存：由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存（Tos，Top-of-Stack Cashing）技术，将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率。
 3. 动态链接
    - 实际上和组成原理中的动态链接一样，为了节省空间，在方法被编译成字节码文件时，引用别的方法或对象都是符号引用。动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用
 4. 方法返回地址
 
 5. 附加信息  
 ## 静态变量与局部变量的对比
> 变量的分类：
> 1、按照数据类型分：① 基本数据类型  ② 引用数据类型   
> 
> 2、按照在类中声明的位置分：  
> 
>  2-1、成员变量：在使用前，都经历过默认初始化赋值  
>
>       2-1-1、类变量: linking的prepare阶段：给类变量默认赋值
>              ---> initial阶段：给类变量显式赋值及静态代码块赋值
>       2-1-2、实例变量：随着对象的创建，会在堆空间中分配实例变量空间，并 进行默认赋值
>  2-2、局部变量：在使用前，必须要进行显式赋值的！否则，编译不通过。
## 静态链接与动态链接
* 静态链接  
当一个字节码文件被装载进JVM内部时，在编译期间就能够确定被调用的方法，且在运行期保持不变，那么就能够直接将调用方法的符号引用变成直接引用，这个过程成为静态链接
* 动态链接  
反之，如果编译期间不能确定被调用的方法，那么就要在运行期间将符号引用转换成直接引用，这是这种转换成为动态链接

## 早期绑定与晚期绑定
早期绑定涵盖了静态链接，晚期绑定涵盖了动态链接。因为绑定是一个<font color="#c0ff3e">字段、方法或者类</font>在符号引用被替换为直接引用的过程

* 编译期可以确定，运行时不变 ---> 早期绑定
* 编译期不能确定，只能在运行时将符号转直接 ---> 晚期绑定

## 多态与绑定
假设有方法A。由于多态性，调用方法时可能不止有一个A方法(子类A方法、父类A方法、方法重写)，这时就要确定调用哪个A方法
* 如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法。反之称为虚方法。

## 动态语言与静态语言
* 在编译期对类型的检查 ---> 静态语言， 静态类型语言是判断<font color="#c0ff3e">变量自身</font>c的类型信息
* 在运行期对类型的检查 ---> 动态语言，动态类型语言是判断<font color="#c0ff3e">变量值</font>的类型信息

## 静态类型与实际类型
* 静态类型和实际类型在程序中都可以发生一些变化
* 区别是静态类型的变化仅仅在使用时发生,变量本身的静态类型不会被改变,并且最终的静态类型是在编译期可知的;而实际类型变化的结果在运行期才可确定

```JAVA
// 实际类型变化
Human man=new Man(); 
man=new Woman();
// 静态类型变化
sr.sayHello((Man)man);
sr.sayHello((Woman)man);c
```
## 动态分派与静态分派
* 重载时是通过参数的静态类型而不是实际类型作为判定依据的
* 所有依赖静态类型来定位方法执行版本的分派动作称为静态分派。<font color="#c0ff3e">静态分派的典型应用是方法重载。静态分派发生在编译阶段,</font>因此确定静态分派的动作实际上不是由虚拟机来执行的。另外 ,编译器虽然能确定出方法的重载版本,但在很多情况下这个重载版本并不 是“唯一的” ,往往只能确定一个“更加合适的”版本。
* chongxie 
###  invokevirtual指令的多态查找过程
1.  找到操作数栈顶的第一个元素所执行的对象的<font color="#c0ff3e">实际类型</font>，记作C。
2.  如果在类型C中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验。
    *   如果通过则返回这个方法的直接引用，查找过程结束
    *   如果不通过，则返回java.lang.IllegalAccessError 异常
3.  否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程。
4.  如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。