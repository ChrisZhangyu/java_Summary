# <center>简介</center>
## 基于栈的指令集与基于寄存器的指令集
  * 基于寄存器的指令集
      >   x86结构，指令多为一地址指令，二地址指令，执行时需要的指令少，但指令集较多。依赖于硬件。
  * 基于栈的指令集
      >   单个指令集功能简单，执行时需要的指令多，但指令集整体少。最重要的是
        <font color="#00dddd">跨平台性
        </font><br /> 
## jvm的生命周期
    * 启动
      >     通过引导类加载器创建一个初始类完成，初始类由具体的虚拟机实现
       
    * 运行
      >     执行java程序，实际上是执行了一个虚拟机进程
  
    * 退出
      >     退出有正常退出、异常或错误终止、手动调用System.exit或Runtime.halt退出
## 解释器与即时编译器(编译器后端)
  * 解释器
    >   对每一行程序进行解释执行，如果重复执行一些语句也会重新解释执行，即不会缓存解释后的代码
  * 即时编译器JIT(Just In Time)
    >   利用热点探测技术，将高频执行的代码进行编译并缓存，则在解释器执行时可以直接进行调用而不用再进行解释 

# <center>类的加载
## 类加载器
  主要负责将字节码文件加载到JVM的方法区，分为加载、验证、准备、解析、初始化五个阶段。方法区不仅保存了类信息，还包括常量池信息、字符串字面量、数字常量。java字节码文件以特定信息开头，即class字节码文件的开头为CA FE BA BE。字节码文件以二进制文件的形式存在
  * ### 加载
    * 通过类的全限定名获取类的二进制字节流
    * 将字节流所代表的静态存储结构转化为方法区的运行时数据结构。？？？
    * 在内存中生成一个代表该类的对象，java.lang.Class对象，该对象作为方法区中该类的各种数据的访问接口
  * ### 链接(验证、准备、解析)
    * 验证。
        >   确保当前class文件符合java虚拟机的要求，保证类的加载的正确性，不会危害自身虚拟机的安全。主要有四种验证：文件格式验证、元数据验证、字节码验证、符号引用验证。具体的验证内容：https://blog.csdn.net/dufufd/article/details/80538527

         
    * 准备。
        >   为<font color="#00dddd0">类变量(即静态变量，static修饰的变量)</font>分配内存并且设置类变量的默认初始值。<font color="#00dddd">注意，默认初始值不是程序中的初始值。</font>举例来说，int型变量的默认初始值为0，引用类型为null，布尔类型未false。
    * 解析
        >   将符号引用转为直接引用
     
  * ### 初始化
    >   执行类构造器方法(不是类的构造器)<font color="#023FFFF">\<clinit></font>方法。此方法为所有的类中的静态变量赋值，并且执行静态代码块。会按源文件中的语句的顺序执行。  
    若此类有父类，则会先对父类进行加载，先执行父类的<font color="#023FFFF">\<clinit></font>方法  
    多线程场景下，该方法会被加锁，执行且仅执行一次。

## 三种加载器
  三种加载器是父子关系，但并不是继承关系，是一种包含。
  * 1.引导类加载器(C/C++实现)
  >   加载java的核心类库,不继承ClassLoader的抽象类，因为不是java语言写的。只加载包名为java、javax、sun等核心类。 
  * 2.扩展类加载器
  >   继承了ClassLoader抽象类，负责加载java.ext.dirs属性指定的目录中的类，以及jre/lib/ext目录下的类，如果用户创建的类也在该目录下，则也会由扩展类加载器加载。
  * 3.系统类加载器(应用程序类加载器)
  >   负责加载classpath中的类，以及java.class.path属性指定的目录中的类。是程序默认的类加载器
## 双亲委派机制
  ![avatar](../双亲委派.png)
  >   java的类加载是按需加载，当真正使用某个类时才将其加载到内存中。双亲委派机制是类加载器分配加载任务的一种方式，即需要加载的类优先由上级加载类进行加载(一直向上传递直到引导类加载器)，上级加载类无法加载，再下放到下级加载器，逐层传递。  
  优势是能避免重复加载，而且保证了核心类的安全，防止核心类被随意篡改。
## 类的主动使用与被动使用
  >   区别：被动使用的类不会执行clinit方法，也就是不执行初始化。
  * 创建类的实例
  * 访问某个类或接口的静态变量，或者对该静态变量赋值
  * 调用类的静态方法
  * 反射（比如：Class.forName（"com.atguigu.Test"））
  * 初始化一个类的子类
  * Java 虚拟机启动时被标明为启动类的类
  * JDK 7 开始提供的动态语言支持：
java.lang.invoke.MethodHandle 实例的解析结果
REF_getStatic、REF_putStatic、REF_invokeStatic 句柄对应的类没有初始化，则初始化

